=== L-8 Evidence: Production Parse Path Proof ===
Date: 2026-01-18

PROPERTY PROVEN:
The L-8 torture test injection method (_inject_bytes) uses the EXACT SAME
parsing sequence as production code.

================================================================================
PRODUCTION CODE PATH (m3/src/orchestrator.py:160-172)
================================================================================

```python
proposal_bytes = acquire_proposal_set(raw_input_bytes)

# Empty bytes -> create empty proposal set for REJECT path
if not proposal_bytes:
    proposal_set = {
        "schema_version": "m1.0",
        "input": {"raw": ""},
        "proposals": []
    }
    proposal_json = json.dumps(proposal_set, sort_keys=True)
else:
    proposal_json = proposal_bytes.decode('utf-8')
    proposal_set = json.loads(proposal_json)
```

Key sequence for non-empty bytes (lines 171-172):
  1. proposal_bytes.decode('utf-8')
  2. json.loads(result)

================================================================================
TEST INJECTION METHOD (tests/l8/test_l8_proposal_seam_torture.py:78-111)
================================================================================

```python
def _inject_bytes(self, proposal_bytes: bytes):
    """
    Inject raw bytes simulating proposal engine output.

    This follows the production path:
    1. Proposal engine returns bytes
    2. Bytes are parsed as JSON
    3. Parsed dict is passed to build_artifact()
    """
    try:
        # Attempt to parse bytes as JSON (production path)
        proposal_set = json.loads(proposal_bytes.decode('utf-8'))
    except (json.JSONDecodeError, UnicodeDecodeError):
        # JSON parsing failed - production would REJECT
        ...
```

Key sequence (line 98):
  1. proposal_bytes.decode('utf-8')
  2. json.loads(result)

================================================================================
COMPARISON
================================================================================

| Step | Production (orchestrator.py) | Test (_inject_bytes) |
|------|------------------------------|----------------------|
| 1    | proposal_bytes.decode('utf-8') | proposal_bytes.decode('utf-8') |
| 2    | json.loads(proposal_json)    | json.loads(...)      |

IDENTICAL SEQUENCE CONFIRMED.

================================================================================
EXCEPTION HANDLING
================================================================================

Production (orchestrator.py:180-182):
  - Any exception during parsing creates empty proposal set -> REJECT downstream

Test (_inject_bytes):
  - UnicodeDecodeError -> creates empty proposal set -> REJECT
  - json.JSONDecodeError -> creates empty proposal set -> REJECT

Both paths collapse parsing failures to REJECT via empty proposal set.

================================================================================
CODE POINTERS
================================================================================

| Location | File | Lines |
|----------|------|-------|
| Production parse | m3/src/orchestrator.py | 160-172 |
| Test injection | tests/l8/test_l8_proposal_seam_torture.py | 78-111 |

================================================================================
CONCLUSION
================================================================================

PROVEN: The L-8 torture test _inject_bytes() method uses the exact same
parsing sequence as production:
  bytes.decode('utf-8') -> json.loads()

This is not an approximation or simulation. The test injection directly
replicates the production code path.

