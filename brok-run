#!/usr/bin/env python3
"""
Brok-CLU Wrapper - Derived UX Convenience Layer (Phase L-6)

This is an OPTIONAL wrapper around the canonical ./brok CLI.
It provides a convenience interface for interactive use.

IMPORTANT - Authority Model:
  - This wrapper is DERIVED and NON-AUTHORITATIVE
  - The canonical command remains: ./brok --input <file>
  - stdout.raw.kv is the ONLY authoritative execution output
  - The JSON summary printed by this wrapper is DERIVED

Usage:
    ./brok-run "create payment"

Output contract (exactly two lines on success):
  Line 1: JSON with frozen schema (all fields always present)
  Line 2: "Authoritative output: <path>" or "Authoritative output: NONE"

Run identification method (L-6):
  Filesystem delta within artifacts/run/ (black-box, no internal coupling)
  - Snapshot directories before ./brok invocation
  - Snapshot directories after ./brok invocation
  - Multiple new directories allowed per invocation
  - Authority selection: exactly one directory with stdout.raw.kv
"""

import hashlib
import json
import os
import subprocess
import sys
import tempfile

# Resolve repo root from this script's location
_SCRIPT_PATH = os.path.abspath(__file__)
_REPO_ROOT = os.path.dirname(_SCRIPT_PATH)
_BROK_PATH = os.path.join(_REPO_ROOT, "brok")

# Canonical run root (constant, matching established repo structure)
_RUN_ROOT = os.path.join(_REPO_ROOT, "artifacts", "run")

# Exit codes
_EXIT_WRONG_ARGS = 2
_EXIT_WRAPPER_FAILURE = 3


def _sha256_file(path: str) -> str:
    """Compute SHA-256 hex digest of a file."""
    hasher = hashlib.sha256()
    with open(path, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            hasher.update(chunk)
    return hasher.hexdigest()


def _snapshot_run_dirs(run_root: str = None) -> set:
    """Snapshot immediate child directories of run root."""
    root = run_root or _RUN_ROOT
    if not os.path.isdir(root):
        return set()
    return set(os.listdir(root))


def _compute_delta(before: set, after: set) -> set:
    """Compute newly created directories."""
    return after - before


def _find_authoritative_dirs(new_dirs: set, run_root: str = None) -> list:
    """
    Find directories containing stdout.raw.kv (authoritative execution output).

    L-6 contract: authority is determined solely by presence of stdout.raw.kv.
    Directory names, timestamps, ordering, sizes are ignored.

    Returns list of absolute paths to directories containing stdout.raw.kv.
    """
    root = run_root or _RUN_ROOT
    authoritative = []
    for dir_name in new_dirs:
        dir_path = os.path.join(root, dir_name)
        stdout_path = os.path.join(dir_path, "stdout.raw.kv")
        if os.path.isfile(stdout_path):
            authoritative.append(dir_path)
    return authoritative


def _find_observability_dir(new_dirs: set, run_root: str = None) -> str | None:
    """
    Find an observability directory (one with manifest.json but no stdout.raw.kv).

    Used to read decision when no execution occurred.
    """
    root = run_root or _RUN_ROOT
    for dir_name in new_dirs:
        dir_path = os.path.join(root, dir_name)
        manifest_path = os.path.join(dir_path, "manifest.json")
        stdout_path = os.path.join(dir_path, "stdout.raw.kv")
        if os.path.isfile(manifest_path) and not os.path.isfile(stdout_path):
            return dir_path
    return None


def _read_manifest(run_dir: str) -> dict | None:
    """Read manifest.json from run directory."""
    manifest_path = os.path.join(run_dir, "manifest.json")
    if not os.path.isfile(manifest_path):
        return None
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return None


def _get_artifact_path_from_manifest(manifest: dict) -> str | None:
    """Extract artifact.json path from manifest."""
    artifacts = manifest.get("artifacts", [])
    for artifact in artifacts:
        if artifact.get("type") == "artifact":
            rel_path = artifact.get("path")
            if rel_path:
                return os.path.join(_REPO_ROOT, rel_path)
    return None


def _read_decision_from_artifact(artifact_path: str) -> str | None:
    """Read decision from artifact.json."""
    if not os.path.isfile(artifact_path):
        return None
    try:
        with open(artifact_path, 'r', encoding='utf-8') as f:
            artifact = json.load(f)
        return artifact.get("decision")
    except (json.JSONDecodeError, IOError):
        return None


def _get_stdout_raw_kv(run_dir: str) -> tuple[str | None, str | None]:
    """Get stdout.raw.kv path and hash from run directory."""
    stdout_path = os.path.join(run_dir, "stdout.raw.kv")
    if os.path.isfile(stdout_path):
        try:
            return stdout_path, _sha256_file(stdout_path)
        except (IOError, OSError):
            return None, None
    return None, None


def _find_decision_from_new_dirs(new_dirs: set, run_root: str = None) -> str | None:
    """
    Find decision by reading manifest from any new directory.

    Tries authoritative dirs first, then observability dirs.
    """
    root = run_root or _RUN_ROOT
    for dir_name in new_dirs:
        dir_path = os.path.join(root, dir_name)
        manifest = _read_manifest(dir_path)
        if manifest:
            artifact_path = _get_artifact_path_from_manifest(manifest)
            if artifact_path:
                decision = _read_decision_from_artifact(artifact_path)
                if decision:
                    return decision
    return None


def main():
    # Wrong argument handling: single usage line to stderr
    if len(sys.argv) != 2:
        print("Usage: ./brok-run \"<input string>\"", file=sys.stderr)
        return _EXIT_WRONG_ARGS

    input_string = sys.argv[1]

    # Create temporary input file
    temp_fd = None
    temp_path = None
    try:
        temp_fd, temp_path = tempfile.mkstemp(
            prefix="brok_input_",
            suffix=".txt",
            dir=os.path.join(_REPO_ROOT, "artifacts")
        )

        # Write input string with trailing newline
        content = (input_string + "\n").encode('utf-8')
        os.write(temp_fd, content)
        os.close(temp_fd)
        temp_fd = None

        # STEP 1: Snapshot before invocation
        dirs_before = _snapshot_run_dirs()

        # STEP 2: Invoke canonical ./brok command
        result = subprocess.run(
            [_BROK_PATH, "--input", temp_path],
            capture_output=True,
            text=True,
            cwd=_REPO_ROOT
        )

        # STEP 3: Snapshot after invocation and compute delta
        dirs_after = _snapshot_run_dirs()
        new_dirs = _compute_delta(dirs_before, dirs_after)

        # L-6: Multiple directories per logical run are allowed
        # Authority selection based solely on stdout.raw.kv presence

        # STEP 4: Find authoritative directories (those with stdout.raw.kv in delta)
        authoritative_dirs = _find_authoritative_dirs(new_dirs)

        # STEP 5: Apply L-6 selection rule
        if len(authoritative_dirs) > 1:
            # Contract violation: multiple authoritative directories
            print(f"Wrapper failure: contract violation - {len(authoritative_dirs)} directories contain stdout.raw.kv", file=sys.stderr)
            return _EXIT_WRAPPER_FAILURE

        # Determine run_dir and authoritative output
        authoritative_run_dir = None
        authoritative_path = None
        authoritative_hash = None

        if len(authoritative_dirs) == 1:
            # Exactly one authoritative directory in delta - use it
            authoritative_run_dir = authoritative_dirs[0]
            stdout_path, stdout_hash = _get_stdout_raw_kv(authoritative_run_dir)
            if stdout_path is None:
                # stdout.raw.kv exists but is unreadable
                print("Wrapper failure: stdout.raw.kv is unreadable", file=sys.stderr)
                return _EXIT_WRAPPER_FAILURE
            authoritative_path = stdout_path
            authoritative_hash = stdout_hash

        # L-6 Path A: If 0 authoritative dirs in delta, treat as "no execution occurred"
        # Do NOT attempt to derive execution directory from manifest or outside delta

        # STEP 6: Find decision from any new directory with manifest
        decision = _find_decision_from_new_dirs(new_dirs)
        if decision is None:
            print("Wrapper failure: cannot determine decision from artifacts", file=sys.stderr)
            return _EXIT_WRAPPER_FAILURE

        # STEP 7: Determine run_dir for JSON output
        # Use authoritative dir if available, otherwise use observability dir
        if authoritative_run_dir:
            run_dir = authoritative_run_dir
        else:
            # No execution - use observability directory
            obs_dir = _find_observability_dir(new_dirs)
            if obs_dir:
                run_dir = obs_dir
            elif len(new_dirs) > 0:
                # Fall back to any new directory
                run_dir = os.path.join(_RUN_ROOT, next(iter(new_dirs)))
            else:
                print("Wrapper failure: no new directories created", file=sys.stderr)
                return _EXIT_WRAPPER_FAILURE

        # Frozen JSON schema: all four fields always present
        summary = {
            "run_dir": run_dir,
            "decision": decision,
            "authoritative_stdout_raw_kv": authoritative_path,
            "authoritative_stdout_raw_kv_sha256": authoritative_hash,
        }

        # L-6B: Explicit warning for ACCEPT + null authoritative (Path A contract boundary)
        if decision == "ACCEPT" and authoritative_path is None:
            print(
                "Warning: ACCEPT reported, but no stdout.raw.kv was found in newly created run directories (delta-only discovery).",
                file=sys.stderr
            )
            print(
                "Note: Under Path A, brok-run does not search outside the delta set for authoritative output.",
                file=sys.stderr
            )

        # Output line 1: JSON (frozen schema, single line)
        print(json.dumps(summary, separators=(',', ':')))

        # Output line 2: Authoritative output
        if authoritative_path:
            print(f"Authoritative output: {authoritative_path}")
        else:
            print("Authoritative output: NONE")

        # Propagate exit code from ./brok
        return result.returncode

    finally:
        # Clean up temp file
        if temp_fd is not None:
            try:
                os.close(temp_fd)
            except OSError:
                pass
        if temp_path and os.path.exists(temp_path):
            try:
                os.unlink(temp_path)
            except OSError:
                pass


if __name__ == "__main__":
    sys.exit(main())
