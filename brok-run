#!/usr/bin/env python3
"""
Brok-CLU Wrapper - Derived UX Convenience Layer (Phase L-7)

This is an OPTIONAL wrapper around the canonical ./brok CLI.
It provides a convenience interface for interactive use.

IMPORTANT - Authority Model:
  - This wrapper is DERIVED and NON-AUTHORITATIVE
  - The canonical command remains: ./brok --input <file>
  - stdout.raw.kv is the ONLY authoritative execution output
  - The JSON summary printed by this wrapper is DERIVED
  - Discovery does not imply execution truth

Usage:
    ./brok-run "create payment"

Output contract (exactly two lines on success):
  Line 1: JSON with frozen schema (all fields always present)
  Line 2: "Authoritative output: <path>" or "Authoritative output: NONE" or "Authoritative output: AMBIGUOUS"

Run identification method (L-7):
  1. Delta-only discovery (L-6 behavior): Check newly created directories for stdout.raw.kv
  2. Expanded discovery (L-7): If delta-only fails and decision=ACCEPT:
     - Read stdout.raw.kv SHA256 from manifest (written by ./brok)
     - Scan all stdout.raw.kv files under artifacts/run/
     - Match by SHA256 (deterministic, no timestamps/ordering)
     - Outcomes: unique (exactly 1 match), none (0 matches), ambiguous (>1 matches)

Locator outcomes (L-7):
  - "authoritative_found": Unique stdout.raw.kv located (via delta or expanded discovery)
  - "authoritative_not_found": No stdout.raw.kv could be located
  - "authoritative_ambiguous": Multiple candidates, wrapper refuses to select
"""

import hashlib
import json
import os
import subprocess
import sys
import tempfile

# Resolve repo root from this script's location
_SCRIPT_PATH = os.path.abspath(__file__)
_REPO_ROOT = os.path.dirname(_SCRIPT_PATH)
_BROK_PATH = os.path.join(_REPO_ROOT, "brok")

# Canonical run root (constant, matching established repo structure)
_RUN_ROOT = os.path.join(_REPO_ROOT, "artifacts", "run")

# Exit codes
_EXIT_WRONG_ARGS = 2
_EXIT_WRAPPER_FAILURE = 3


def _sha256_file(path: str) -> str:
    """Compute SHA-256 hex digest of a file."""
    hasher = hashlib.sha256()
    with open(path, 'rb') as f:
        for chunk in iter(lambda: f.read(8192), b''):
            hasher.update(chunk)
    return hasher.hexdigest()


def _snapshot_run_dirs(run_root: str = None) -> set:
    """Snapshot immediate child directories of run root."""
    root = run_root or _RUN_ROOT
    if not os.path.isdir(root):
        return set()
    return set(os.listdir(root))


def _compute_delta(before: set, after: set) -> set:
    """Compute newly created directories."""
    return after - before


def _find_authoritative_dirs(new_dirs: set, run_root: str = None) -> list:
    """
    Find directories containing stdout.raw.kv (authoritative execution output).

    L-6 contract: authority is determined solely by presence of stdout.raw.kv.
    Directory names, timestamps, ordering, sizes are ignored.

    Returns list of absolute paths to directories containing stdout.raw.kv.
    """
    root = run_root or _RUN_ROOT
    authoritative = []
    for dir_name in new_dirs:
        dir_path = os.path.join(root, dir_name)
        stdout_path = os.path.join(dir_path, "stdout.raw.kv")
        if os.path.isfile(stdout_path):
            authoritative.append(dir_path)
    return authoritative


def _find_observability_dir(new_dirs: set, run_root: str = None) -> str | None:
    """
    Find an observability directory (one with manifest.json but no stdout.raw.kv).

    Used to read decision when no execution occurred.
    """
    root = run_root or _RUN_ROOT
    for dir_name in new_dirs:
        dir_path = os.path.join(root, dir_name)
        manifest_path = os.path.join(dir_path, "manifest.json")
        stdout_path = os.path.join(dir_path, "stdout.raw.kv")
        if os.path.isfile(manifest_path) and not os.path.isfile(stdout_path):
            return dir_path
    return None


def _read_manifest(run_dir: str) -> dict | None:
    """Read manifest.json from run directory."""
    manifest_path = os.path.join(run_dir, "manifest.json")
    if not os.path.isfile(manifest_path):
        return None
    try:
        with open(manifest_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return None


def _get_artifact_path_from_manifest(manifest: dict) -> str | None:
    """Extract artifact.json path from manifest."""
    artifacts = manifest.get("artifacts", [])
    for artifact in artifacts:
        if artifact.get("type") == "artifact":
            rel_path = artifact.get("path")
            if rel_path:
                return os.path.join(_REPO_ROOT, rel_path)
    return None


def _read_decision_from_artifact(artifact_path: str) -> str | None:
    """Read decision from artifact.json."""
    if not os.path.isfile(artifact_path):
        return None
    try:
        with open(artifact_path, 'r', encoding='utf-8') as f:
            artifact = json.load(f)
        return artifact.get("decision")
    except (json.JSONDecodeError, IOError):
        return None


def _get_stdout_raw_kv(run_dir: str) -> tuple[str | None, str | None]:
    """Get stdout.raw.kv path and hash from run directory."""
    stdout_path = os.path.join(run_dir, "stdout.raw.kv")
    if os.path.isfile(stdout_path):
        try:
            return stdout_path, _sha256_file(stdout_path)
        except (IOError, OSError):
            return None, None
    return None, None


def _find_decision_from_new_dirs(new_dirs: set, run_root: str = None) -> str | None:
    """
    Find decision by reading manifest from any new directory.

    Tries authoritative dirs first, then observability dirs.
    """
    root = run_root or _RUN_ROOT
    for dir_name in new_dirs:
        dir_path = os.path.join(root, dir_name)
        manifest = _read_manifest(dir_path)
        if manifest:
            artifact_path = _get_artifact_path_from_manifest(manifest)
            if artifact_path:
                decision = _read_decision_from_artifact(artifact_path)
                if decision:
                    return decision
    return None


# =============================================================================
# L-7: Locator Outcome Model and Expanded Discovery
# =============================================================================

# Locator outcome kinds
LOCATOR_UNIQUE = "unique"
LOCATOR_NONE = "none"
LOCATOR_AMBIGUOUS = "ambiguous"

# Discovery status for UX (derived, non-authoritative)
DISCOVERY_FOUND = "authoritative_found"
DISCOVERY_NOT_FOUND = "authoritative_not_found"
DISCOVERY_AMBIGUOUS = "authoritative_ambiguous"


def _get_stdout_sha256_from_manifest(manifest: dict) -> str | None:
    """
    Extract stdout.raw.kv SHA256 from manifest.

    L-7: This is the stable pointer written by ./brok (not wrapper).
    Used for deterministic matching in expanded discovery.
    """
    artifacts = manifest.get("artifacts", [])
    for artifact in artifacts:
        if artifact.get("type") == "stdout.raw.kv":
            return artifact.get("sha256")
    return None


def _scan_all_stdout_raw_kv(run_root: str = None) -> list:
    """
    Scan all stdout.raw.kv files under run root.

    L-7: Returns list of (path, sha256) tuples.
    Uses sorted() on directory names to ensure deterministic iteration order.
    Does NOT use timestamps, mtimes, or file ordering from OS.
    """
    root = run_root or _RUN_ROOT
    results = []
    if not os.path.isdir(root):
        return results

    # Sort directory names for deterministic iteration (alphabetical, not by time)
    for dir_name in sorted(os.listdir(root)):
        dir_path = os.path.join(root, dir_name)
        if not os.path.isdir(dir_path):
            continue
        stdout_path = os.path.join(dir_path, "stdout.raw.kv")
        if os.path.isfile(stdout_path):
            try:
                file_hash = _sha256_file(stdout_path)
                results.append((stdout_path, file_hash))
            except (IOError, OSError):
                # Skip unreadable files
                pass
    return results


def _find_by_sha256(target_sha256: str, candidates: list) -> list:
    """
    Find all candidates matching the target SHA256.

    L-7: Deterministic matching by content hash.
    Returns list of paths that match.
    """
    matches = []
    for path, file_hash in candidates:
        if file_hash == target_sha256:
            matches.append(path)
    return matches


def _expanded_discovery(manifest: dict, run_root: str = None) -> tuple:
    """
    L-7 Expanded Discovery: Find authoritative output by SHA256 matching.

    Allowed inputs (governed inspection):
    - manifest.json from the observability directory (written by ./brok)
    - All stdout.raw.kv files under artifacts/run/ (read-only scan)

    Forbidden:
    - Timestamps, mtimes, ctimes, atimes
    - File ordering from OS (we sort alphabetically)
    - "Latest", "most recent", or any time-based selection
    - Heuristics or probabilistic matching

    Returns: (outcome_kind, path_or_none, details_dict)
    """
    root = run_root or _RUN_ROOT

    # Step 1: Get target SHA256 from manifest
    target_sha256 = _get_stdout_sha256_from_manifest(manifest)
    if target_sha256 is None:
        return (LOCATOR_NONE, None, {"reason": "no_sha256_in_manifest"})

    # Step 2: Scan all stdout.raw.kv files
    candidates = _scan_all_stdout_raw_kv(root)
    if len(candidates) == 0:
        return (LOCATOR_NONE, None, {"reason": "no_stdout_files_found", "target_sha256": target_sha256})

    # Step 3: Find matches by SHA256
    matches = _find_by_sha256(target_sha256, candidates)

    # Step 4: Apply L-7 selection rule
    if len(matches) == 0:
        return (LOCATOR_NONE, None, {
            "reason": "no_sha256_match",
            "target_sha256": target_sha256,
            "candidates_scanned": len(candidates)
        })
    elif len(matches) == 1:
        return (LOCATOR_UNIQUE, matches[0], {
            "reason": "unique_sha256_match",
            "target_sha256": target_sha256,
            "candidates_scanned": len(candidates)
        })
    else:
        # Multiple matches - AMBIGUOUS (never pick one)
        return (LOCATOR_AMBIGUOUS, None, {
            "reason": "multiple_sha256_matches",
            "target_sha256": target_sha256,
            "match_count": len(matches),
            "candidates_scanned": len(candidates)
        })


def main():
    # Wrong argument handling: single usage line to stderr
    if len(sys.argv) != 2:
        print("Usage: ./brok-run \"<input string>\"", file=sys.stderr)
        return _EXIT_WRONG_ARGS

    input_string = sys.argv[1]

    # Create temporary input file
    temp_fd = None
    temp_path = None
    try:
        temp_fd, temp_path = tempfile.mkstemp(
            prefix="brok_input_",
            suffix=".txt",
            dir=os.path.join(_REPO_ROOT, "artifacts")
        )

        # Write input string with trailing newline
        content = (input_string + "\n").encode('utf-8')
        os.write(temp_fd, content)
        os.close(temp_fd)
        temp_fd = None

        # STEP 1: Snapshot before invocation
        dirs_before = _snapshot_run_dirs()

        # STEP 2: Invoke canonical ./brok command
        result = subprocess.run(
            [_BROK_PATH, "--input", temp_path],
            capture_output=True,
            text=True,
            cwd=_REPO_ROOT
        )

        # STEP 3: Snapshot after invocation and compute delta
        dirs_after = _snapshot_run_dirs()
        new_dirs = _compute_delta(dirs_before, dirs_after)

        # L-6: Multiple directories per logical run are allowed
        # Authority selection based solely on stdout.raw.kv presence

        # STEP 4: Find authoritative directories (those with stdout.raw.kv in delta)
        authoritative_dirs = _find_authoritative_dirs(new_dirs)

        # STEP 5: Apply L-6 selection rule
        if len(authoritative_dirs) > 1:
            # Contract violation: multiple authoritative directories
            print(f"Wrapper failure: contract violation - {len(authoritative_dirs)} directories contain stdout.raw.kv", file=sys.stderr)
            return _EXIT_WRAPPER_FAILURE

        # Determine run_dir and authoritative output
        authoritative_run_dir = None
        authoritative_path = None
        authoritative_hash = None
        discovery_status = DISCOVERY_NOT_FOUND  # Default
        locator_details = {}

        if len(authoritative_dirs) == 1:
            # Exactly one authoritative directory in delta - use it (L-6 behavior)
            authoritative_run_dir = authoritative_dirs[0]
            stdout_path, stdout_hash = _get_stdout_raw_kv(authoritative_run_dir)
            if stdout_path is None:
                # stdout.raw.kv exists but is unreadable
                print("Wrapper failure: stdout.raw.kv is unreadable", file=sys.stderr)
                return _EXIT_WRAPPER_FAILURE
            authoritative_path = stdout_path
            authoritative_hash = stdout_hash
            discovery_status = DISCOVERY_FOUND
            locator_details = {"method": "delta_only", "reason": "found_in_delta"}

        # STEP 6: Find decision from any new directory with manifest
        decision = _find_decision_from_new_dirs(new_dirs)
        if decision is None:
            print("Wrapper failure: cannot determine decision from artifacts", file=sys.stderr)
            return _EXIT_WRAPPER_FAILURE

        # STEP 7: Determine run_dir for JSON output
        # Use authoritative dir if available, otherwise use observability dir
        obs_dir = None
        if authoritative_run_dir:
            run_dir = authoritative_run_dir
        else:
            # No authoritative in delta - use observability directory
            obs_dir = _find_observability_dir(new_dirs)
            if obs_dir:
                run_dir = obs_dir
            elif len(new_dirs) > 0:
                # Fall back to any new directory
                run_dir = os.path.join(_RUN_ROOT, next(iter(new_dirs)))
            else:
                print("Wrapper failure: no new directories created", file=sys.stderr)
                return _EXIT_WRAPPER_FAILURE

        # L-7: Expanded discovery when delta-only fails and decision=ACCEPT
        if decision == "ACCEPT" and authoritative_path is None and obs_dir:
            manifest = _read_manifest(obs_dir)
            if manifest:
                outcome_kind, found_path, details = _expanded_discovery(manifest)
                locator_details = {"method": "expanded", **details}

                if outcome_kind == LOCATOR_UNIQUE:
                    # Unique match found via SHA256
                    authoritative_path = found_path
                    authoritative_hash = _sha256_file(found_path)
                    discovery_status = DISCOVERY_FOUND
                elif outcome_kind == LOCATOR_AMBIGUOUS:
                    # Multiple matches - refuse to select
                    discovery_status = DISCOVERY_AMBIGUOUS
                else:
                    # No match
                    discovery_status = DISCOVERY_NOT_FOUND
            else:
                locator_details = {"method": "expanded", "reason": "no_manifest"}
                discovery_status = DISCOVERY_NOT_FOUND

        # L-7 JSON schema: all fields always present (extends L-6 schema)
        summary = {
            "run_dir": run_dir,
            "decision": decision,
            "authoritative_stdout_raw_kv": authoritative_path,
            "authoritative_stdout_raw_kv_sha256": authoritative_hash,
            "discovery_status": discovery_status,
        }

        # Output line 1: JSON (frozen schema, single line)
        print(json.dumps(summary, separators=(',', ':')))

        # Output line 2: Authoritative output status
        if discovery_status == DISCOVERY_FOUND:
            print(f"Authoritative output: {authoritative_path}")
        elif discovery_status == DISCOVERY_AMBIGUOUS:
            print("Authoritative output: AMBIGUOUS")
        else:
            print("Authoritative output: NONE")

        # L-7: Disclaimer line (wrapper is non-authoritative, discovery != execution truth)
        print("Note: This wrapper is non-authoritative. Discovery status does not imply execution truth.", file=sys.stderr)

        # Propagate exit code from ./brok
        return result.returncode

    finally:
        # Clean up temp file
        if temp_fd is not None:
            try:
                os.close(temp_fd)
            except OSError:
                pass
        if temp_path and os.path.exists(temp_path):
            try:
                os.unlink(temp_path)
            except OSError:
                pass


if __name__ == "__main__":
    sys.exit(main())
